
#include "shader.h"

//全部在fragment里计算 精度highp
const char vertex_shader_highp[] =
"attribute vec4 position;\n"
"varying vec4 v_position;\n"
"void main()\n"
"{\n"
"gl_Position = position;\n"
"v_position = position;\n"
"}\n";

const char fragment_shader_highp_v[] =
"#extension GL_OES_EGL_image_external : require\n"
"precision highp float;\n"
"uniform samplerExternalOES tex_1;\n"
"uniform samplerExternalOES tex_2;\n"
"uniform samplerExternalOES tex_3;\n"
"uniform samplerExternalOES tex_4;\n"
"uniform samplerExternalOES tex_5;\n"
"uniform samplerExternalOES tex_6;\n"
"uniform sampler2D map_1;\n"
"uniform sampler2D map_2;\n"
"uniform sampler2D map_3;\n"
"uniform sampler2D map_4;\n"
"uniform sampler2D map_5;\n"
"uniform sampler2D map_6;\n"
"uniform mat4 rotate_mat4;\n"
"uniform float width;\n"
"uniform float height;\n"
"varying vec4 v_position;\n"
"void main()\n"
"{\n"
"vec2 tex = vec2((v_position.x + 1.0)/2.0, 1.0 - (v_position.y + 1.0)/2.0);\n"
"float M_PI = 3.1415926;\n"
"float u = tex.s * 2.0 * M_PI;\n"
"float v =  tex.t * M_PI;"
"vec4 spherePos;\n"
"spherePos.x = sin(v) * cos(u);\n"
"spherePos.y = sin(v) * sin(u);\n"
"spherePos.z = cos(v);\n"
"spherePos.w = 1.0;\n"
"vec4 lastPos = rotate_mat4 * spherePos;\n"
"float v_last = atan(sqrt(lastPos.x * lastPos.x + lastPos.y * lastPos.y),lastPos.z);\n"
"float u_last = mod(atan(lastPos.y,lastPos.x) + 2.0 * M_PI, 2.0 * M_PI);\n"
"tex = vec2(u_last / (2.0 * M_PI), v_last / M_PI );\n"
"tex.x = tex.x * ( 1.0 - 1.0 / width) + 1.0 / (2.0 * width);\n"
"tex.y = tex.y * ( 1.0 - 1.0 / height) + 1.0 / (2.0 * height);\n"
"vec4 frag_tex_1 = texture2D(map_1, tex);\n"
"vec4 frag_tex_2 = texture2D(map_2, tex);\n"
"vec4 frag_tex_3 = texture2D(map_3, tex);\n"
"vec4 frag_tex_4 = texture2D(map_4, tex);\n"
"vec4 frag_tex_5 = texture2D(map_5, tex);\n"
"vec4 frag_tex_6 = texture2D(map_6, tex);\n"
"gl_FragColor = vec4(0.0, 0.0, 0.0, 0.0);\n"
"if (frag_tex_1.z != 0.0 ){\n"
"    gl_FragColor += texture2D(tex_1, frag_tex_1.xy) * frag_tex_1.z;\n"
"}\n"
"if (frag_tex_2.z != 0.0 ){\n"
"    gl_FragColor += texture2D(tex_2, frag_tex_2.xy) * frag_tex_2.z;\n"
"}\n"
"if (frag_tex_3.z != 0.0 ){\n"
"    gl_FragColor += texture2D(tex_3, frag_tex_3.xy) * frag_tex_3.z;\n"
"}\n"
"if (frag_tex_4.z != 0.0 ){\n"
"    gl_FragColor += texture2D(tex_4, frag_tex_4.xy) * frag_tex_4.z;\n"
"}\n"
"if (frag_tex_5.z != 0.0 ){\n"
"    gl_FragColor += texture2D(tex_5, frag_tex_5.xy) * frag_tex_5.z;\n"
"}\n"
"if (frag_tex_6.z != 0.0 ){\n"
"    gl_FragColor += texture2D(tex_6, frag_tex_6.xy) * frag_tex_6.z;\n"
"}\n"
"}";

const char fragment_shader_highp_p[] =
"precision highp float;\n"
"uniform sampler2D tex_1;\n"
"uniform sampler2D tex_2;\n"
"uniform sampler2D tex_3;\n"
"uniform sampler2D tex_4;\n"
"uniform sampler2D tex_5;\n"
"uniform sampler2D tex_6;\n"
"uniform sampler2D map_1;\n"
"uniform sampler2D map_2;\n"
"uniform sampler2D map_3;\n"
"uniform sampler2D map_4;\n"
"uniform sampler2D map_5;\n"
"uniform sampler2D map_6;\n"
"uniform mat4 rotate_mat4;\n"
"uniform float width;\n"
"uniform float height;\n"
"varying vec4 v_position;\n"
"void main()\n"
"{\n"
"vec2 tex = vec2((v_position.x + 1.0)/2.0, 1.0 - (v_position.y + 1.0)/2.0);\n"
"float M_PI = 3.1415926;\n"
"float u = tex.s * 2.0 * M_PI;\n"
"float v =  tex.t * M_PI;"
"vec4 spherePos;\n"
"spherePos.x = sin(v) * cos(u);\n"
"spherePos.y = sin(v) * sin(u);\n"
"spherePos.z = cos(v);\n"
"spherePos.w = 1.0;\n"
"vec4 lastPos = rotate_mat4 * spherePos;\n"
"float v_last = atan(sqrt(lastPos.x * lastPos.x + lastPos.y * lastPos.y),lastPos.z);\n"
"float u_last = mod(atan(lastPos.y,lastPos.x) + 2.0 * M_PI, 2.0 * M_PI);\n"
"tex = vec2(u_last / (2.0 * M_PI), v_last / M_PI );\n"
"tex.x = tex.x * ( 1.0 - 1.0 / width) + 1.0 / (2.0 * width);\n"
"tex.y = tex.y * ( 1.0 - 1.0 / height) + 1.0 / (2.0 * height);\n"
"vec4 frag_tex_1 = texture2D(map_1, tex);\n"
"vec4 frag_tex_2 = texture2D(map_2, tex);\n"
"vec4 frag_tex_3 = texture2D(map_3, tex);\n"
"vec4 frag_tex_4 = texture2D(map_4, tex);\n"
"vec4 frag_tex_5 = texture2D(map_5, tex);\n"
"vec4 frag_tex_6 = texture2D(map_6, tex);\n"
"gl_FragColor = vec4(0.0, 0.0, 0.0, 0.0);\n"
"if (frag_tex_1.z != 0.0 ){\n"
"    gl_FragColor += texture2D(tex_1, frag_tex_1.xy) * frag_tex_1.z;\n"
"}\n"
"if (frag_tex_2.z != 0.0 ){\n"
"    gl_FragColor += texture2D(tex_2, frag_tex_2.xy) * frag_tex_2.z;\n"
"}\n"
"if (frag_tex_3.z != 0.0 ){\n"
"    gl_FragColor += texture2D(tex_3, frag_tex_3.xy) * frag_tex_3.z;\n"
"}\n"
"if (frag_tex_4.z != 0.0 ){\n"
"    gl_FragColor += texture2D(tex_4, frag_tex_4.xy) * frag_tex_4.z;\n"
"}\n"
"if (frag_tex_5.z != 0.0 ){\n"
"    gl_FragColor += texture2D(tex_5, frag_tex_5.xy) * frag_tex_5.z;\n"
"}\n"
"if (frag_tex_6.z != 0.0 ){\n"
"    gl_FragColor += texture2D(tex_6, frag_tex_6.xy) * frag_tex_6.z;\n"
"}\n"
"}";

//全部在fragment里计算 精度medium
const char vertex_shader_frag[] =
	"attribute vec4 position;\n"
	"varying vec4 v_position;\n"
	"void main()\n"
	"{\n"
	"gl_Position = position;\n"
	"v_position = position;\n"
	"}\n";

const char fragment_shader_frag_v[] =
	"#extension GL_OES_EGL_image_external : require\n"
	"precision mediump float;\n"
	"uniform samplerExternalOES tex_1;\n"
	"uniform samplerExternalOES tex_2;\n"
	"uniform samplerExternalOES tex_3;\n"
	"uniform samplerExternalOES tex_4;\n"
	"uniform samplerExternalOES tex_5;\n"
	"uniform samplerExternalOES tex_6;\n"
	"uniform sampler2D map_1;\n"
	"uniform sampler2D map_2;\n"
	"uniform sampler2D map_3;\n"
	"uniform sampler2D map_4;\n"
	"uniform sampler2D map_5;\n"
	"uniform sampler2D map_6;\n"
	"uniform mat4 rotate_mat4;\n"
	"uniform float width;\n"
	"uniform float height;\n"
	"varying vec4 v_position;\n"
	"void main()\n"
	"{\n"
	"vec2 tex = vec2((v_position.x + 1.0)/2.0, 1.0 - (v_position.y + 1.0)/2.0);\n"
	"float M_PI = 3.1415926;\n"
    "float u = tex.s * 2.0 * M_PI;\n"
    "float v =  tex.t * M_PI;"
    "vec4 spherePos;\n"
    "spherePos.x = sin(v) * cos(u);\n"
    "spherePos.y = sin(v) * sin(u);\n"
    "spherePos.z = cos(v);\n"
    "spherePos.w = 1.0;\n"
    "vec4 lastPos = rotate_mat4 * spherePos;\n"
    "float v_last = atan(sqrt(lastPos.x * lastPos.x + lastPos.y * lastPos.y),lastPos.z);\n"
    "float u_last = mod(atan(lastPos.y,lastPos.x) + 2.0 * M_PI, 2.0 * M_PI);\n"
    "tex = vec2(u_last / (2.0 * M_PI), v_last / M_PI );\n"
	"tex.x = tex.x * ( 1.0 - 1.0 / width) + 1.0 / (2.0 * width);\n"
	"tex.y = tex.y * ( 1.0 - 1.0 / height) + 1.0 / (2.0 * height);\n"
	"vec4 frag_tex_1 = texture2D(map_1, tex);\n"
	"vec4 frag_tex_2 = texture2D(map_2, tex);\n"
	"vec4 frag_tex_3 = texture2D(map_3, tex);\n"
	"vec4 frag_tex_4 = texture2D(map_4, tex);\n"
	"vec4 frag_tex_5 = texture2D(map_5, tex);\n"
	"vec4 frag_tex_6 = texture2D(map_6, tex);\n"
	"vec2 coord_1 = frag_tex_1.rg;\n"
	"vec2 coord_2 = frag_tex_2.rg;\n"
	"vec2 coord_3 = frag_tex_3.rg;\n"
	"vec2 coord_4 = frag_tex_4.rg;\n"
	"vec2 coord_5 = frag_tex_5.rg;\n"
	"vec2 coord_6 = frag_tex_6.rg;\n"
	"float alpha_1 = frag_tex_1.b;\n"
	"float alpha_2 = frag_tex_2.b;\n"
	"float alpha_3 = frag_tex_3.b;\n"
	"float alpha_4 = frag_tex_4.b;\n"
	"float alpha_5 = frag_tex_5.b;\n"
	"float alpha_6 = frag_tex_6.b;\n"
	"gl_FragColor = vec4(0.0,0.0,0.0,0.0);\n"
	"if (alpha_1 != 0.0)\n"
	"{\n"
	"	gl_FragColor += texture2D(tex_1, coord_1)*alpha_1;\n"
	"}\n"
	"if (alpha_2 != 0.0)\n"
	"{\n"
	"	gl_FragColor += texture2D(tex_2, coord_2)*alpha_2;\n"
	"}\n"
	"if (alpha_3 != 0.0)\n"
	"{\n"
	"	gl_FragColor += texture2D(tex_3, coord_3)*alpha_3;\n"
	"}\n"
	"if (alpha_4 != 0.0)\n"
	"{\n"
	"	gl_FragColor += texture2D(tex_4, coord_4)*alpha_4;\n"
	"}\n"
	"if (alpha_5 != 0.0)\n"
	"{\n"
	"	gl_FragColor += texture2D(tex_5, coord_5)*alpha_5;\n"
	"}\n"
	"if (alpha_6 != 0.0)\n"
	"{\n"
	"	gl_FragColor += texture2D(tex_6, coord_6)*alpha_6;\n"
	"}\n"
	"}\n";

const char fragment_shader_frag_p[] =
	"#extension GL_OES_EGL_image_external : require\n"
	"precision mediump float;\n"
	"uniform sampler2D tex_1;\n"
	"uniform sampler2D tex_2;\n"
	"uniform sampler2D tex_3;\n"
	"uniform sampler2D tex_4;\n"
	"uniform sampler2D tex_5;\n"
	"uniform sampler2D tex_6;\n"
	"uniform sampler2D map_1;\n"
	"uniform sampler2D map_2;\n"
	"uniform sampler2D map_3;\n"
	"uniform sampler2D map_4;\n"
	"uniform sampler2D map_5;\n"
	"uniform sampler2D map_6;\n"
	"uniform mat4 rotate_mat4;\n"
	"uniform float width;\n"
	"uniform float height;\n"
	"varying vec4 v_position;\n"
	"void main()\n"
	"{\n"
	"vec2 tex = vec2((v_position.x + 1.0)/2.0, 1.0 - (v_position.y + 1.0)/2.0);\n"
	"float M_PI = 3.1415926;\n"
    "float u = tex.s * 2.0 * M_PI;\n"
    "float v =  tex.t * M_PI;"
    "vec4 spherePos;\n"
    "spherePos.x = sin(v) * cos(u);\n"
    "spherePos.y = sin(v) * sin(u);\n"
    "spherePos.z = cos(v);\n"
    "spherePos.w = 1.0;\n"
    "vec4 lastPos = rotate_mat4 * spherePos;\n"
    "float v_last = atan(sqrt(lastPos.x * lastPos.x + lastPos.y * lastPos.y),lastPos.z);\n"
    "float u_last = mod(atan(lastPos.y,lastPos.x) + 2.0 * M_PI, 2.0 * M_PI);\n"
    "tex = vec2(u_last / (2.0 * M_PI), v_last / M_PI );\n"
	"tex.x = tex.x * ( 1.0 - 1.0 / width) + 1.0 / (2.0 * width);\n"
	"tex.y = tex.y * ( 1.0 - 1.0 / height) + 1.0 / (2.0 * height);\n"
	"vec4 frag_tex_1 = texture2D(map_1, tex);\n"
	"vec4 frag_tex_2 = texture2D(map_2, tex);\n"
	"vec4 frag_tex_3 = texture2D(map_3, tex);\n"
	"vec4 frag_tex_4 = texture2D(map_4, tex);\n"
	"vec4 frag_tex_5 = texture2D(map_5, tex);\n"
	"vec4 frag_tex_6 = texture2D(map_6, tex);\n"
	"vec2 coord_1 = frag_tex_1.rg;\n"
	"vec2 coord_2 = frag_tex_2.rg;\n"
	"vec2 coord_3 = frag_tex_3.rg;\n"
	"vec2 coord_4 = frag_tex_4.rg;\n"
	"vec2 coord_5 = frag_tex_5.rg;\n"
	"vec2 coord_6 = frag_tex_6.rg;\n"
	"float alpha_1 = frag_tex_1.b;\n"
	"float alpha_2 = frag_tex_2.b;\n"
	"float alpha_3 = frag_tex_3.b;\n"
	"float alpha_4 = frag_tex_4.b;\n"
	"float alpha_5 = frag_tex_5.b;\n"
	"float alpha_6 = frag_tex_6.b;\n"
	"gl_FragColor = vec4(0.0,0.0,0.0,0.0);\n"
	"if (alpha_1 != 0.0)\n"
	"{\n"
	"	gl_FragColor += texture2D(tex_1, coord_1)*alpha_1;\n"
	"}\n"
	"if (alpha_2 != 0.0)\n"
	"{\n"
	"	gl_FragColor += texture2D(tex_2, coord_2)*alpha_2;\n"
	"}\n"
	"if (alpha_3 != 0.0)\n"
	"{\n"
	"	gl_FragColor += texture2D(tex_3, coord_3)*alpha_3;\n"
	"}\n"
	"if (alpha_4 != 0.0)\n"
	"{\n"
	"	gl_FragColor += texture2D(tex_4, coord_4)*alpha_4;\n"
	"}\n"
	"if (alpha_5 != 0.0)\n"
	"{\n"
	"	gl_FragColor += texture2D(tex_5, coord_5)*alpha_5;\n"
	"}\n"
	"if (alpha_6 != 0.0)\n"
	"{\n"
	"	gl_FragColor += texture2D(tex_6, coord_6)*alpha_6;\n"
	"}\n"
	"}\n";

//全部在vetex里计算 精度medium
const char vertex_shader[] =
	"attribute vec4 position;\n"
	"uniform sampler2D map_1;\n"
	"uniform sampler2D map_2;\n"
	"uniform sampler2D map_3;\n"
	"uniform sampler2D map_4;\n"
	"uniform sampler2D map_5;\n"
	"uniform sampler2D map_6;\n"
	"uniform mat4 rotate_mat4;\n"
	"uniform float width;\n"
	"uniform float height;\n"
	"varying vec4 frag_tex_1;\n"
	"varying vec4 frag_tex_2;\n"
	"varying vec4 frag_tex_3;\n"
	"varying vec4 frag_tex_4;\n"
	"varying vec4 frag_tex_5;\n"
	"varying vec4 frag_tex_6;\n"
	"void main()\n"
	"{\n"
	"gl_Position = position;\n"
	"vec2 tex = vec2((position.x + 1.0)/2.0, 1.0 - (position.y + 1.0)/2.0);\n"
	"float M_PI = 3.1415926;\n"
    "float u = tex.s * 2.0 * M_PI;\n"
    "float v =  tex.t * M_PI;"
    "vec4 spherePos;\n"
    "spherePos.x = sin(v) * cos(u);\n"
    "spherePos.y = sin(v) * sin(u);\n"
    "spherePos.z = cos(v);\n"
    "spherePos.w = 1.0;\n"
    "vec4 lastPos = rotate_mat4 * spherePos;\n"
    "float v_last = atan(sqrt(lastPos.x * lastPos.x + lastPos.y * lastPos.y),lastPos.z);\n"
    "float u_last = mod(atan(lastPos.y,lastPos.x) + 2.0 * M_PI, 2.0 * M_PI);\n"
    "tex = vec2(u_last / (2.0 * M_PI), v_last / M_PI );\n"
	"tex.x = tex.x * ( 1.0 - 1.0 / width) + 1.0 / (2.0 * width);\n"
	"tex.y = tex.y * ( 1.0 - 1.0 / height) + 1.0 / (2.0 * height);\n"
	"frag_tex_1 = texture2D(map_1, tex);\n"
	"frag_tex_2 = texture2D(map_2, tex);\n"
	"frag_tex_3 = texture2D(map_3, tex);\n"
	"frag_tex_4 = texture2D(map_4, tex);\n"
	"frag_tex_5 = texture2D(map_5, tex);\n"
	"frag_tex_6 = texture2D(map_6, tex);\n"
	"}\n";

const char fragment_shader_v[] =
	"#extension GL_OES_EGL_image_external : require\n"
	"precision mediump float;\n"
	"uniform samplerExternalOES tex_1;\n"
	"uniform samplerExternalOES tex_2;\n"
	"uniform samplerExternalOES tex_3;\n"
	"uniform samplerExternalOES tex_4;\n"
	"uniform samplerExternalOES tex_5;\n"
	"uniform samplerExternalOES tex_6;\n"
	"varying vec4 frag_tex_1;\n"
	"varying vec4 frag_tex_2;\n"
	"varying vec4 frag_tex_3;\n"
	"varying vec4 frag_tex_4;\n"
	"varying vec4 frag_tex_5;\n"
	"varying vec4 frag_tex_6;\n"
	"void main()\n"
	"{\n"
	"vec2 coord_1 = frag_tex_1.rg;\n"
	"vec2 coord_2 = frag_tex_2.rg;\n"
	"vec2 coord_3 = frag_tex_3.rg;\n"
	"vec2 coord_4 = frag_tex_4.rg;\n"
	"vec2 coord_5 = frag_tex_5.rg;\n"
	"vec2 coord_6 = frag_tex_6.rg;\n"
	"float alpha_1 = frag_tex_1.b;\n"
	"float alpha_2 = frag_tex_2.b;\n"
	"float alpha_3 = frag_tex_3.b;\n"
	"float alpha_4 = frag_tex_4.b;\n"
	"float alpha_5 = frag_tex_5.b;\n"
	"float alpha_6 = frag_tex_6.b;\n"
	"gl_FragColor = vec4(0.0,0.0,0.0,0.0);\n"
	"if (alpha_1 != 0.0)\n"
	"{\n"
	"	gl_FragColor += texture2D(tex_1, coord_1)*alpha_1;\n"
	"}\n"
	"if (alpha_2 != 0.0)\n"
	"{\n"
	"	gl_FragColor += texture2D(tex_2, coord_2)*alpha_2;\n"
	"}\n"
	"if (alpha_3 != 0.0)\n"
	"{\n"
	"	gl_FragColor += texture2D(tex_3, coord_3)*alpha_3;\n"
	"}\n"
	"if (alpha_4 != 0.0)\n"
	"{\n"
	"	gl_FragColor += texture2D(tex_4, coord_4)*alpha_4;\n"
	"}\n"
	"if (alpha_5 != 0.0)\n"
	"{\n"
	"	gl_FragColor += texture2D(tex_5, coord_5)*alpha_5;\n"
	"}\n"
	"if (alpha_6 != 0.0)\n"
	"{\n"
	"	gl_FragColor += texture2D(tex_6, coord_6)*alpha_6;\n"
	"}\n"
	"}\n";

const char fragment_shader_p[] =
	"precision mediump float;\n"
	"uniform sampler2D tex_1;\n"
	"uniform sampler2D tex_2;\n"
	"uniform sampler2D tex_3;\n"
	"uniform sampler2D tex_4;\n"
	"uniform sampler2D tex_5;\n"
	"uniform sampler2D tex_6;\n"
	"varying vec4 frag_tex_1;\n"
	"varying vec4 frag_tex_2;\n"
	"varying vec4 frag_tex_3;\n"
	"varying vec4 frag_tex_4;\n"
	"varying vec4 frag_tex_5;\n"
	"varying vec4 frag_tex_6;\n"
	"void main()\n"
	"{\n"
	"vec2 coord_1 = frag_tex_1.rg;\n"
	"vec2 coord_2 = frag_tex_2.rg;\n"
	"vec2 coord_3 = frag_tex_3.rg;\n"
	"vec2 coord_4 = frag_tex_4.rg;\n"
	"vec2 coord_5 = frag_tex_5.rg;\n"
	"vec2 coord_6 = frag_tex_6.rg;\n"
	"float alpha_1 = frag_tex_1.b;\n"
	"float alpha_2 = frag_tex_2.b;\n"
	"float alpha_3 = frag_tex_3.b;\n"
	"float alpha_4 = frag_tex_4.b;\n"
	"float alpha_5 = frag_tex_5.b;\n"
	"float alpha_6 = frag_tex_6.b;\n"
	"gl_FragColor = vec4(0.0,0.0,0.0,0.0);\n"
	"if (alpha_1 != 0.0)\n"
	"{\n"
	"	gl_FragColor += texture2D(tex_1, coord_1)*alpha_1;\n"
	"}\n"
	"if (alpha_2 != 0.0)\n"
	"{\n"
	"	gl_FragColor += texture2D(tex_2, coord_2)*alpha_2;\n"
	"}\n"
	"if (alpha_3 != 0.0)\n"
	"{\n"
	"	gl_FragColor += texture2D(tex_3, coord_3)*alpha_3;\n"
	"}\n"
	"if (alpha_4 != 0.0)\n"
	"{\n"
	"	gl_FragColor += texture2D(tex_4, coord_4)*alpha_4;\n"
	"}\n"
	"if (alpha_5 != 0.0)\n"
	"{\n"
	"	gl_FragColor += texture2D(tex_5, coord_5)*alpha_5;\n"
	"}\n"
	"if (alpha_6 != 0.0)\n"
	"{\n"
	"	gl_FragColor += texture2D(tex_6, coord_6)*alpha_6;\n"
	"}\n"
	"}\n";

const char vertex_shader_optimize[] =
"attribute vec4 position;\n"
"varying vec4 v_position;\n"
"void main()\n"
"{\n"
"gl_Position = position;\n"
"v_position = position;\n"
"}\n";

const char fragment_shader_optimize_v[] =
"#extension GL_OES_EGL_image_external : require\n"
"precision highp float;\n"
"uniform samplerExternalOES tex_1;\n"
"uniform samplerExternalOES tex_2;\n"
"uniform samplerExternalOES tex_3;\n"
"uniform samplerExternalOES tex_4;\n"
"uniform samplerExternalOES tex_5;\n"
"uniform samplerExternalOES tex_6;\n"
"uniform samplerExternalOES tex_7;\n"
"uniform samplerExternalOES tex_8;\n"
"uniform sampler2D tex_logo;\n"
"uniform sampler2D map_alpha1234;\n"
"uniform sampler2D map_alpha5678;\n"
"uniform sampler2D map_coord12;\n"
"uniform sampler2D map_coord34;\n"
"uniform sampler2D map_coord56;\n"
"uniform sampler2D map_coord78;\n"
"uniform mat4 rotate_mat4;\n"
"uniform float width;\n"
"uniform float height;\n"
"uniform float logo_ratio;\n"
"varying vec4 v_position;\n"
"void main()\n"
"{\n"
"if (logo_ratio != 0.0 && v_position.y < -(1.0-logo_ratio*2.0))"
"{"
"	vec2 tex = vec2((v_position.x + 1.0)/2.0, -(v_position.y + 1.0-logo_ratio*2.0)/logo_ratio/2.0);\n"
"	gl_FragColor = texture2D(tex_logo, tex);\n"
"}"
"else"
"{"
"vec2 tex = vec2((v_position.x + 1.0)/2.0, 1.0 - (v_position.y + 1.0)/2.0);\n"
"float M_PI = 3.1415926;\n"
"float u = tex.s * 2.0 * M_PI;\n"
"float v =  tex.t * M_PI;"
"vec4 spherePos;\n"
"spherePos.x = sin(v) * cos(u);\n"
"spherePos.y = sin(v) * sin(u);\n"
"spherePos.z = cos(v);\n"
"spherePos.w = 1.0;\n"
"vec4 lastPos = rotate_mat4 * spherePos;\n"
"float v_last = atan(sqrt(lastPos.x * lastPos.x + lastPos.y * lastPos.y),lastPos.z);\n"
"float u_last = mod(atan(lastPos.y,lastPos.x) + 2.0 * M_PI, 2.0 * M_PI);\n"
"tex = vec2(u_last / (2.0 * M_PI), v_last / M_PI );\n"
"tex.x = tex.x * ( 1.0 - 1.0 / width) + 1.0 / (2.0 * width);\n"
"tex.y = tex.y * ( 1.0 - 1.0 / height) + 1.0 / (2.0 * height);\n"
"vec4 alpha_1234 = texture2D(map_alpha1234, tex);\n"
"vec4 alpha_5678 = texture2D(map_alpha5678, tex);\n"
"gl_FragColor = vec4(0.0, 0.0, 0.0, 0.0);\n"
"if (alpha_1234.x != 0.0 || alpha_1234.y != 0.0) {\n"
"    vec4 frag_tex_12 = texture2D(map_coord12, tex);\n"
"    if (alpha_1234.x != 0.0){\n"
"        gl_FragColor += texture2D(tex_1, frag_tex_12.xy) * alpha_1234.x;\n"
"    }\n"
"    if (alpha_1234.y != 0.0){\n"
"        gl_FragColor += texture2D(tex_2, frag_tex_12.zw) * alpha_1234.y;\n"
"    }\n"
"}\n"
"if (alpha_1234.z != 0.0 || alpha_1234.w != 0.0){\n"
"    vec4 frag_tex_34 = texture2D(map_coord34, tex);\n"
"    if (alpha_1234.z != 0.0){\n"
"        gl_FragColor += texture2D(tex_3, frag_tex_34.xy) * alpha_1234.z;\n"
"    }\n"
"    if (alpha_1234.w != 0.0){\n"
"        gl_FragColor += texture2D(tex_4, frag_tex_34.zw) * alpha_1234.w;\n"
"    }\n"
"}\n"
"if (alpha_5678.x != 0.0 || alpha_5678.y != 0.0){\n"
"    vec4 frag_tex_56 = texture2D(map_coord56, tex);\n"
"    if (alpha_5678.x != 0.0) {\n"
"        gl_FragColor += texture2D(tex_5, frag_tex_56.xy) * alpha_5678.x;\n"
"    }\n"
"    if (alpha_5678.y != 0.0) {\n"
"        gl_FragColor += texture2D(tex_6, frag_tex_56.zw) * alpha_5678.y;\n"
"    }\n"
"}\n"
"if (alpha_5678.z != 0.0 || alpha_5678.w != 0.0){\n"
"    vec4 frag_tex_78 = texture2D(map_coord78, tex);\n"
"    if (alpha_5678.z != 0.0) {\n"
"        gl_FragColor += texture2D(tex_7, frag_tex_78.xy) * alpha_5678.z;\n"
"    }\n"
"    if (alpha_5678.w != 0.0) {\n"
"        gl_FragColor += texture2D(tex_8, frag_tex_78.zw) * alpha_5678.w;\n"
"    }\n"
"}\n"
"}\n"
"}";

const char fragment_shader_optimize_p[] =
"#extension GL_OES_EGL_image_external : require\n"
"precision highp float;\n"
"uniform sampler2D tex_1;\n"
"uniform sampler2D tex_2;\n"
"uniform sampler2D tex_3;\n"
"uniform sampler2D tex_4;\n"
"uniform sampler2D tex_5;\n"
"uniform sampler2D tex_6;\n"
"uniform sampler2D tex_logo;\n"
"uniform sampler2D map_alpha123;\n"
"uniform sampler2D map_alpha456;\n"
"uniform sampler2D map_coord12;\n"
"uniform sampler2D map_coord34;\n"
"uniform sampler2D map_coord56;\n"
"uniform mat4 rotate_mat4;\n"
"uniform float width;\n"
"uniform float height;\n"
"uniform float logo_ratio;\n"
"varying vec4 v_position;\n"
"void main()\n"
"{\n"
"if (logo_ratio != 0.0 && v_position.y < -(1.0-logo_ratio*2.0))"
"{"
"	vec2 tex = vec2((v_position.x + 1.0)/2.0, -(v_position.y + 1.0-logo_ratio*2.0)/logo_ratio/2.0);\n"
"	gl_FragColor = texture2D(tex_logo, tex);\n"
"}"
"else"
"{"
"vec2 tex = vec2((v_position.x + 1.0)/2.0, 1.0 - (v_position.y + 1.0)/2.0);\n"
"float M_PI = 3.1415926;\n"
"float u = tex.s * 2.0 * M_PI;\n"
"float v =  tex.t * M_PI;"
"vec4 spherePos;\n"
"spherePos.x = sin(v) * cos(u);\n"
"spherePos.y = sin(v) * sin(u);\n"
"spherePos.z = cos(v);\n"
"spherePos.w = 1.0;\n"
"vec4 lastPos = rotate_mat4 * spherePos;\n"
"float v_last = atan(sqrt(lastPos.x * lastPos.x + lastPos.y * lastPos.y),lastPos.z);\n"
"float u_last = mod(atan(lastPos.y,lastPos.x) + 2.0 * M_PI, 2.0 * M_PI);\n"
"tex = vec2(u_last / (2.0 * M_PI), v_last / M_PI );\n"
"tex.x = tex.x * ( 1.0 - 1.0 / width) + 1.0 / (2.0 * width);\n"
"tex.y = tex.y * ( 1.0 - 1.0 / height) + 1.0 / (2.0 * height);\n"
"vec4 alpha_123 = texture2D(map_alpha123, tex);\n"
"vec4 alpha_456 = texture2D(map_alpha456, tex);\n"
"gl_FragColor = vec4(0.0, 0.0, 0.0, 0.0);\n"
"if (alpha_123.x != 0.0 || alpha_123.y != 0.0) {\n"
"    vec4 frag_tex_12 = texture2D(map_coord12, tex);\n"
"    if (alpha_123.x != 0.0){\n"
"        gl_FragColor += texture2D(tex_1, frag_tex_12.xy) * alpha_123.x;\n"
"    }\n"
"    if (alpha_123.y != 0.0){\n"
"        gl_FragColor += texture2D(tex_2, frag_tex_12.zw) * alpha_123.y;\n"
"    }\n"
"}\n"
"if (alpha_123.z != 0.0 || alpha_456.x != 0.0){\n"
"    vec4 frag_tex_34 = texture2D(map_coord34, tex);\n"
"    if (alpha_123.z != 0.0){\n"
"        gl_FragColor += texture2D(tex_3, frag_tex_34.xy) * alpha_123.z;\n"
"    }\n"
"    if (alpha_456.x != 0.0){\n"
"        gl_FragColor += texture2D(tex_4, frag_tex_34.zw) * alpha_456.x;\n"
"    }\n"
"}\n"
"if (alpha_456.y != 0.0 || alpha_456.z != 0.0){\n"
"    vec4 frag_tex_56 = texture2D(map_coord56, tex);\n"
"    if (alpha_456.y != 0.0) {\n"
"        gl_FragColor += texture2D(tex_5, frag_tex_56.xy) * alpha_456.y;\n"
"    }\n"
"    if (alpha_456.z != 0.0) {\n"
"        gl_FragColor += texture2D(tex_6, frag_tex_56.zw) * alpha_456.z;\n"
"    }\n"
"}\n"
"}"
"}";

const char vertex_shader_quad[] =
	"attribute vec4 position;\n"
	"attribute vec2 vertTexCoord;\n"
	"varying vec2 fragTexCoord;\n"
	"void main()\n"
	"{\n"
	"fragTexCoord = vertTexCoord;\n"
	"gl_Position = position;\n"
	"}\n";

const char fragment_shader_quad[] =
    "precision mediump float;\n"
	"uniform sampler2D tex;\n"
	"varying vec2 fragTexCoord;\n"
	"void main()\n"
	"{\n"
	"gl_FragColor = texture2D(tex, fragTexCoord);\n"
	"}\n";

const char fragment_shader_quad_external[] =
	"#extension GL_OES_EGL_image_external : require\n"
    "precision highp float;\n"
	"uniform samplerExternalOES tex;\n"
	"varying vec2 fragTexCoord;\n"
	"void main()\n"
	"{\n"
	"gl_FragColor = texture2D(tex, fragTexCoord);\n"
	"}\n";

const char fragment_shader_optimize_p_cube[] =
"#extension GL_OES_EGL_image_external : require\n"
"precision highp float;\n"
"uniform sampler2D tex_1;\n"
"uniform sampler2D tex_2;\n"
"uniform sampler2D tex_3;\n"
"uniform sampler2D tex_4;\n"
"uniform sampler2D tex_5;\n"
"uniform sampler2D tex_6;\n"
"uniform sampler2D tex_logo;\n"
"uniform sampler2D map_alpha123;\n"
"uniform sampler2D map_alpha456;\n"
"uniform sampler2D map_coord12;\n"
"uniform sampler2D map_coord34;\n"
"uniform sampler2D map_coord56;\n"
"uniform mat4 rotate_mat4;\n"
"uniform float width;\n"
"uniform float height;\n"
"uniform float logo_ratio;\n"
"varying vec4 v_position;\n"
"void main()\n"
"{\n"
"float x = (v_position.x + 1.0)/2.0*3.0;\n"
"float y = (1.0 - (v_position.y + 1.0)/2.0)*2.0;\n"
"float x1, y1, z1, tx, ty;\n"
"if (y < 1.0)\n"
"{\n"
"	if (x < 1.0)\n"
"	{\n"
"		tx = x;\n"
"		ty = y;\n"
"		tx = (tx - 0.5)*1.01 + 0.5;\n"
"		ty = (ty - 0.5)*1.01 + 0.5;\n"
"		x1 = tx - 0.5;\n"
"		y1 = 0.5;\n"
"		z1 = 0.5 - ty;\n"
"	}\n"
"	else if (x < 2.0)\n"
"	{\n"
"		tx = x - 1.0;\n"
"		ty = y;\n"
"		tx = (tx - 0.5)*1.01 + 0.5;\n"
"		ty = (ty - 0.5)*1.01 + 0.5;\n"
"		x1 = 0.5 - tx;\n"
"		y1 = -0.5;\n"
"		z1 = 0.5 - ty;\n"
"	}\n"
"	else\n"
"	{\n"
"		tx = x - 2.0;\n"
"		ty = y;\n"
"		tx = (tx - 0.5)*1.01 + 0.5;\n"
"		ty = (ty - 0.5)*1.01 + 0.5;\n"
"		x1 = 0.5 - ty;\n"
"		y1 = tx - 0.5;\n"
"		z1 = 0.5;\n"
"	}\n"
"}\n"
"else\n"
"{\n"
"	if (x < 1.0)\n"
"	{\n"
"		tx = x;\n"
"		ty = y - 1.0;\n"
"		tx = (tx - 0.5) * 1.01 + 0.5;\n"
"		ty = (ty - 0.5) * 1.01 + 0.5;\n"
"		x1 = ty - 0.5;\n"
"		y1 = tx - 0.5;\n"
"		z1 = -0.5;\n"
"	}\n"
"	else if (x < 2.0)\n"
"	{\n"
"		tx = x - 1.0;\n"
"		ty = y - 1.0;\n"
"		tx = (tx - 0.5) * 1.01 + 0.5;\n"
"		ty = (ty - 0.5) * 1.01 + 0.5;\n"
"		x1 = -0.5;\n"
"		y1 = tx - 0.5;\n"
"		z1 = 0.5 - ty;\n"
"	}\n"
"	else\n"
"	{\n"
"		tx = x - 2.0;\n"
"		ty = y - 1.0;\n"
"		tx = (tx - 0.5) * 1.01 + 0.5;\n"
"		ty = (ty - 0.5) * 1.01 + 0.5;\n"
"		x1 = 0.5;\n"
"		y1 = 0.5 - tx;\n"
"		z1 = 0.5 - ty;\n"
"	}\n"
"}\n"
"float norm = sqrt(x1 * x1 + y1 * y1 + z1 * z1);\n"
"vec4 spherePos;\n"
"spherePos.x = x1/norm;\n"
"spherePos.y = -y1/norm;\n"
"spherePos.z = z1/norm;\n"
"spherePos.w = 1.0;\n"
"float M_PI = 3.1415926;\n"
"float flat_y = atan(sqrt(spherePos.x * spherePos.x + spherePos.y * spherePos.y),spherePos.z);\n"
"if (logo_ratio != 0.0 && flat_y/M_PI > (1.0-logo_ratio))"
"{"
"	float flat_x = mod(atan(spherePos.y,spherePos.x) + 2.0 * M_PI, 2.0 * M_PI);\n"
"	vec2 tex = vec2(flat_x / (2.0 * M_PI), (flat_y/M_PI - 1.0 + logo_ratio)/logo_ratio);\n"
"	gl_FragColor = texture2D(tex_logo, tex);\n"
"}"
"else"
"{"
"vec4 lastPos = rotate_mat4 * spherePos;\n"
"float v_last = atan(sqrt(lastPos.x * lastPos.x + lastPos.y * lastPos.y),lastPos.z);\n"
"float u_last = mod(atan(lastPos.y,lastPos.x) + 2.0 * M_PI, 2.0 * M_PI);\n"
"vec2 tex = vec2(u_last / (2.0 * M_PI), v_last / M_PI );\n"
"tex.x = tex.x * ( 1.0 - 1.0 / width) + 1.0 / (2.0 * width);\n"
"tex.y = tex.y * ( 1.0 - 1.0 / height) + 1.0 / (2.0 * height);\n"
"vec4 alpha_123 = texture2D(map_alpha123, tex);\n"
"vec4 alpha_456 = texture2D(map_alpha456, tex);\n"
"gl_FragColor = vec4(0.0, 0.0, 0.0, 0.0);\n"
"if (alpha_123.x != 0.0 || alpha_123.y != 0.0) {\n"
"    vec4 frag_tex_12 = texture2D(map_coord12, tex);\n"
"    if (alpha_123.x != 0.0){\n"
"        gl_FragColor += texture2D(tex_1, frag_tex_12.xy) * alpha_123.x;\n"
"    }\n"
"    if (alpha_123.y != 0.0){\n"
"        gl_FragColor += texture2D(tex_2, frag_tex_12.zw) * alpha_123.y;\n"
"    }\n"
"}\n"
"if (alpha_123.z != 0.0 || alpha_456.x != 0.0){\n"
"    vec4 frag_tex_34 = texture2D(map_coord34, tex);\n"
"    if (alpha_123.z != 0.0){\n"
"        gl_FragColor += texture2D(tex_3, frag_tex_34.xy) * alpha_123.z;\n"
"    }\n"
"    if (alpha_456.x != 0.0){\n"
"        gl_FragColor += texture2D(tex_4, frag_tex_34.zw) * alpha_456.x;\n"
"    }\n"
"}\n"
"if (alpha_456.y != 0.0 || alpha_456.z != 0.0){\n"
"    vec4 frag_tex_56 = texture2D(map_coord56, tex);\n"
"    if (alpha_456.y != 0.0) {\n"
"        gl_FragColor += texture2D(tex_5, frag_tex_56.xy) * alpha_456.y;\n"
"    }\n"
"    if (alpha_456.z != 0.0) {\n"
"        gl_FragColor += texture2D(tex_6, frag_tex_56.zw) * alpha_456.z;\n"
"    }\n"
"}\n"
"}\n"
"}";


const char fragment_shader_optimize_v_cube[] =
"#extension GL_OES_EGL_image_external : require\n"
"precision highp float;\n"
"uniform samplerExternalOES tex_1;\n"
"uniform samplerExternalOES tex_2;\n"
"uniform samplerExternalOES tex_3;\n"
"uniform samplerExternalOES tex_4;\n"
"uniform samplerExternalOES tex_5;\n"
"uniform samplerExternalOES tex_6;\n"
"uniform sampler2D tex_logo;\n"
"uniform sampler2D map_alpha123;\n"
"uniform sampler2D map_alpha456;\n"
"uniform sampler2D map_coord12;\n"
"uniform sampler2D map_coord34;\n"
"uniform sampler2D map_coord56;\n"
"uniform mat4 rotate_mat4;\n"
"uniform float width;\n"
"uniform float height;\n"
"uniform float logo_ratio;\n"
"varying vec4 v_position;\n"
"void main()\n"
"{\n"
"float x = (v_position.x + 1.0)/2.0*3.0;\n"
"float y = (1.0 - (v_position.y + 1.0)/2.0)*2.0;\n"
"float x1, y1, z1, tx, ty;\n"
"if (y < 1.0)\n"
"{\n"
"	if (x < 1.0)\n"
"	{\n"
"		tx = x;\n"
"		ty = y;\n"
"		tx = (tx - 0.5)*1.01 + 0.5;\n"
"		ty = (ty - 0.5)*1.01 + 0.5;\n"
"		x1 = tx - 0.5;\n"
"		y1 = 0.5;\n"
"		z1 = 0.5 - ty;\n"
"	}\n"
"	else if (x < 2.0)\n"
"	{\n"
"		tx = x - 1.0;\n"
"		ty = y;\n"
"		tx = (tx - 0.5)*1.01 + 0.5;\n"
"		ty = (ty - 0.5)*1.01 + 0.5;\n"
"		x1 = 0.5 - tx;\n"
"		y1 = -0.5;\n"
"		z1 = 0.5 - ty;\n"
"	}\n"
"	else\n"
"	{\n"
"		tx = x - 2.0;\n"
"		ty = y;\n"
"		tx = (tx - 0.5)*1.01 + 0.5;\n"
"		ty = (ty - 0.5)*1.01 + 0.5;\n"
"		x1 = 0.5 - ty;\n"
"		y1 = tx - 0.5;\n"
"		z1 = 0.5;\n"
"	}\n"
"}\n"
"else\n"
"{\n"
"	if (x < 1.0)\n"
"	{\n"
"		tx = x;\n"
"		ty = y - 1.0;\n"
"		tx = (tx - 0.5) * 1.01 + 0.5;\n"
"		ty = (ty - 0.5) * 1.01 + 0.5;\n"
"		x1 = ty - 0.5;\n"
"		y1 = tx - 0.5;\n"
"		z1 = -0.5;\n"
"	}\n"
"	else if (x < 2.0)\n"
"	{\n"
"		tx = x - 1.0;\n"
"		ty = y - 1.0;\n"
"		tx = (tx - 0.5) * 1.01 + 0.5;\n"
"		ty = (ty - 0.5) * 1.01 + 0.5;\n"
"		x1 = -0.5;\n"
"		y1 = tx - 0.5;\n"
"		z1 = 0.5 - ty;\n"
"	}\n"
"	else\n"
"	{\n"
"		tx = x - 2.0;\n"
"		ty = y - 1.0;\n"
"		tx = (tx - 0.5) * 1.01 + 0.5;\n"
"		ty = (ty - 0.5) * 1.01 + 0.5;\n"
"		x1 = 0.5;\n"
"		y1 = 0.5 - tx;\n"
"		z1 = 0.5 - ty;\n"
"	}\n"
"}\n"
"float norm = sqrt(x1 * x1 + y1 * y1 + z1 * z1);\n"
"vec4 spherePos;\n"
"spherePos.x = x1/norm;\n"
"spherePos.y = -y1/norm;\n"
"spherePos.z = z1/norm;\n"
"spherePos.w = 1.0;\n"
"float M_PI = 3.1415926;\n"
"float flat_y = atan(sqrt(spherePos.x * spherePos.x + spherePos.y * spherePos.y),spherePos.z);\n"
"if (logo_ratio != 0.0 && flat_y/M_PI > (1.0-logo_ratio))"
"{"
"	float flat_x = mod(atan(spherePos.y,spherePos.x) + 2.0 * M_PI, 2.0 * M_PI);\n"
"	vec2 tex = vec2(flat_x / (2.0 * M_PI), (flat_y/M_PI - 1.0 + logo_ratio)/logo_ratio);\n"
"	gl_FragColor = texture2D(tex_logo, tex);\n"
"}"
"else"
"{"
"vec4 lastPos = rotate_mat4 * spherePos;\n"
"float v_last = atan(sqrt(lastPos.x * lastPos.x + lastPos.y * lastPos.y),lastPos.z);\n"
"float u_last = mod(atan(lastPos.y,lastPos.x) + 2.0 * M_PI, 2.0 * M_PI);\n"
"vec2 tex = vec2(u_last / (2.0 * M_PI), v_last / M_PI );\n"
"tex.x = tex.x * ( 1.0 - 1.0 / width) + 1.0 / (2.0 * width);\n"
"tex.y = tex.y * ( 1.0 - 1.0 / height) + 1.0 / (2.0 * height);\n"
"vec4 alpha_123 = texture2D(map_alpha123, tex);\n"
"vec4 alpha_456 = texture2D(map_alpha456, tex);\n"
"gl_FragColor = vec4(0.0, 0.0, 0.0, 0.0);\n"
"if (alpha_123.x != 0.0 || alpha_123.y != 0.0) {\n"
"    vec4 frag_tex_12 = texture2D(map_coord12, tex);\n"
"    if (alpha_123.x != 0.0){\n"
"        gl_FragColor += texture2D(tex_1, frag_tex_12.xy) * alpha_123.x;\n"
"    }\n"
"    if (alpha_123.y != 0.0){\n"
"        gl_FragColor += texture2D(tex_2, frag_tex_12.zw) * alpha_123.y;\n"
"    }\n"
"}\n"
"if (alpha_123.z != 0.0 || alpha_456.x != 0.0){\n"
"    vec4 frag_tex_34 = texture2D(map_coord34, tex);\n"
"    if (alpha_123.z != 0.0){\n"
"        gl_FragColor += texture2D(tex_3, frag_tex_34.xy) * alpha_123.z;\n"
"    }\n"
"    if (alpha_456.x != 0.0){\n"
"        gl_FragColor += texture2D(tex_4, frag_tex_34.zw) * alpha_456.x;\n"
"    }\n"
"}\n"
"if (alpha_456.y != 0.0 || alpha_456.z != 0.0){\n"
"    vec4 frag_tex_56 = texture2D(map_coord56, tex);\n"
"    if (alpha_456.y != 0.0) {\n"
"        gl_FragColor += texture2D(tex_5, frag_tex_56.xy) * alpha_456.y;\n"
"    }\n"
"    if (alpha_456.z != 0.0) {\n"
"        gl_FragColor += texture2D(tex_6, frag_tex_56.zw) * alpha_456.z;\n"
"    }\n"
"}\n"
"}\n"
"}";

